title,url,time_added,tags,status,content
Edge.org,https://www.edge.org/,1655721705,,unread,"To arrive at the edge of the world's knowledge, seek out the most complex and sophisticated minds, put them in a room together, and have them ask each other the questions they are asking themselves.  JOHN TOOBY (July 26, 1952-November 9, 2023) was the founder of the field of Evolutionary Psychology,Â co-director (with hisÂ wife,Â Leda Cosmides) of the Center for Evolutionary Psychology, and professor of anthropology at UC Santa Barbara. He received his PhD inÂ biological anthropologyÂ fromÂ Harvard UniversityÂ in 1989 and was professor of anthropology at theÂ University of California, Santa Barbara. Tooby and Cosmides also co-founded and co-directed the UCSBÂ Center for Evolutionary Psychology and jointly received the 2020Â Jean Nicod Prize. Tooby was known for his work with his collaborators to integrate cognitive science, cultural anthropology, evolutionary biology, paleoanthropology, cognitive neuroscience, and hunter-gatherer studies to create the new field of evolutionary psychology, toward the goal of the progressive mapping of the universal evolved cognitive and neural architecture that constitutes human nature and provides the basis of the learning mechanisms responsible for culture. This involves using knowledge of specific adaptive problems our hunter-gatherer ancestors encountered to experimentally map the design of the cognitive and emotional mechanisms that evolved among our hominid ancestors to solve them. At UCSB's Center for Evolutionary Psychology, he and his collaborators used cross-cultural, experimental, and neuroscience techniques to investigate specific cognitive specializations for cooperation, coalitions, group psychology, and human reasoning. Under Tooby's direction, the Center maintained a field station in Ecuadorian Amazonia in order to conduct cross-cultural studies of psychological adaptations and human behavioral ecology. He was particularly interested in documenting how the design of these adaptations shapes cultural and social phenomena, and potentially forms the foundation for a new, more precise generation of social and cultural theories. Tooby, a valued member of the Edge community, wrote numerous essays in response to the Edge Annual Question, examples of which we are pleased to share below.Â John Tooby's Edge Bio PageÂ  Coalition-mindedness makes everyone, including scientists, far stupider in coalitional collectivities than as individuals. Paradoxically, a political party united by supernatural beliefs can revise its beliefs about economics or climate without revisers being bad coalition members. But people whose coalitional membership is constituted by their shared adherence to ""rational,"" scientific propositions have a problem whenâ€”as is generally the caseâ€”new information arises which requires belief revision. To question or disagree with coalitional precepts, even for rational reasons, makes one a bad and immoral coalition memberâ€”at risk of losing job offers, one's friends, and one's cherished group identity. This freezes belief revision.Â Â Â  [Continue...] The most remarkable breaking news in science is that I exist. Well, not just me. People like me who, without technology, would have died early. Of the roughly 5.5Â billion people who survived past puberty, perhaps only one billion would be here were it not for modern sanitation, medicine, technology, and market-driven abundance. Ancestrally, the overwhelming majority of humans died before they had a full complement of children, often not making it past childhood. For those who live in developed nations, our remodeled lifetables are among the greatest of the humane triumphs of the Enlightenmentâ€”delivering parents from the grief of holding most of their children dead in their arms, or of children losing their parents (and then themselves dying from want). [Continue...] The universe is vast and full of illimitable layers of rich structure; brains (or computers) in comparison are infinitesimal. To reconcile this size difference, evolution sifted for hacks that were small enough to fit the brain, but that generated huge inferential payoffsâ€”superefficient compression algorithms (inevitably lossy, because one key to effective compression is to throw nearly everything away). [Continue...] All ""learning"" operationally means is that something about the organism's interaction with the environment caused a change in the information states of the brain, by mechanisms unexplained. All ""culture"" means is that some information states in one person's brain somehow cause, by mechanisms unexplained, ""similar"" information states to be reconstructed in another's brain. The assumption is that because supposed instances of ""culture"" (or equally, ""learning"") are referred to with the same name, they are the same kind of thing. Instead, each masks an enormous array of thoroughly dissimilar things. Attempting to construct a science built around culture (or learning) as a unitary concept is as misguided as attempting to develop a robust science of white things (egg shells, clouds, O-type stars, Pat Boone, human scleras, bones, first generation MacBooks, dandelion sap, liliesâ€¦).Â  [Continue...] Indeed, the enterprise of science isâ€”as an idealâ€”specifically devoted to improving the accuracy of beliefs. We can pinpoint where this analysis goes awry, however, when we consider the multiple functions of holding beliefs. We take for granted that the function of a belief is to be coordinated with reality, so that when actions are based on that belief, they succeed. The more often beliefs are tested against reality, the more often accurate beliefs displace inaccurate ones (e.g., through feedback from experiments, engineering tests, markets, natural selection). However, there is a second kind of function to holding a belief that affects whether people consciously or unconsciously come to embrace itâ€”the social payoffs from being coordinated or discoordinated with others' beliefs (Socrates' execution for ""failing to acknowledge the gods the city acknowledges""). The mind is designed to balance these two functions: coordinating with realityÂ and coordinating with others. The larger the payoffs to social coordination, and the less commonly beliefs are tested against reality, then the more social demands will determine beliefâ€”that is, network fixation of belief will predominate. Physics and chip design will have a high degree of coordination with reality, while the social sciences and climatology will have less. [Continue...] The hardest choice I had to make in my early scientific life was whether to give up the beautiful puzzles of quantum mechanics, nonlocality, and cosmology for something equally arresting: to work instead on reverse engineering the code that natural selection had built into the programs that made up our species' circuit architecture. In 1970, the surrounding cultural frenzy and geopolitics made first steps toward a nonideological and computational understanding of our evolved design, ""human nature,""Â seem urgent; the recent rise of computer science and cybernetics made it seem possible; the almost complete avoidance of and hostility to evolutionary biology by behavioral and social scientists had nearly neutered those fields, and so made it seem necessary. [Continue...] Here are three simple conceptual tools that might help us see in front of our noses:Â nexus causality, moral warfare,Â andÂ misattribution arbitrage. Causality itself is an evolved conceptual tool that simplifies, schematizes, and focuses our representation of situations. This cognitive machinery guides us to think in terms ofÂ theÂ causeâ€”of an outcome having a single cause. Yet for enlarged understanding, it is more accurate to represent outcomes as caused by an intersection or nexus of factors (including the absence of precluding conditions). [Continue...] Obliterating whole lineagesâ€”diatoms and dinosaurs, corals and crustaceans, ammonites and amphibiansâ€”shockwaves from the YucatÃ¡n impact 65 million years ago ripped through the intricate interdependencies of the planetary ecosystem, turning blankets of life into shrouds in one incandescent geological instant. Knocking out keystone species and toppling community structures, these shifts and extinctions opened up new opportunities, inviting avian and mammalian adaptive radiations and other bursts of innovation that transformed the living worldâ€”and eventually opening the way for our placenta-suckled, unprecedentedly luxuriant brains. What with one thing and another, now here we are: the Internet and the World Wide Web that runs on it have struck our species' informational ecology with a similarly explosive impact, their shockwaves rippling through our cultural, social, economic, political, technological, scientific, and even cognitive landscapes. [Continue...] Humanity will continue to be blind slaves to the programs that evolution has built into our brains until we drag them into the light. Ordinarily, we only inhabit the versions of reality they spontaneously construct for usâ€”the surfaces of things. Because we are unaware we are in a theater, with our roles and our lines largely written for us by our mental programs, we are credulously swept up in these plays (such as the genocidal drama of us versus them). Endless chain reactions among these programs leave us the victims of historyâ€”embedded in war and oppression, enveloped in mass delusions and cultural epidemics, mired in endless negative sum conflict. [Continue...] Continue Reading â†’  [Editorâ€™s Note:]Â SARA LIPPINCOTT (1938-2023) was an editor specializing in nonfiction who edited some eighty books about science for the general publicÂ including bestsellers such as Bill Bradleyâ€™sÂ Time Present, Time Past,Â Timothy Ferrisâ€™sÂ The Whole Shebang,Â Lee Smolinâ€™s TheÂ Trouble with Physics,Â and John McPheeâ€™s Pulitzer prize-winningÂ Annals of the Former World. A longtime nonfiction editor atÂ The New Yorker, she moved to LosÂ Angeles in 1993, where she taught writing for ten years at CaltechÂ and later became an editor at the now-defunctÂ Los Angeles Times Book Review. From 1996, she edited the sixteen books in the Edge Annual Question series, and the twenty-two books in the Science Masters I and Science Masters II series.Â  Several days ago, Sara called to give me the sad news that she was very ill and the end was near. She also had a request: ""I have something Iâ€™ve written that I would like you to publish onÂ Edge.""Â Yesterday, on Sunday, October 29, 2023,Â Sara died peacefully.Â  Thus, it is with great sadness, but also with a deep sense of love andÂ appreciation, that I share with you Saraâ€™s piece, ""The Tea Table."" ~~ The Tea Table
By Sara Lippincott I got out of Wellesley in 1959, shortly after Lolita got out of Paris. Vladimir Nabokovâ€™s Lolita. (Na-bwak-awf: a trip down the stairs with a loud bump and a glorious sprawl at the bottom.) I fell in love with it. Â Â Â Â Â Â Â Â  I had majored in English, with a minor in Moby Dick, and now planned to become a full-time poet. So I looked for and found a garret in Cambridge, in a seedy gabled house on Kirkland Street. The third floorâ€”two tiny bedrooms and a hall bathâ€”was shared by me and a young woman of about my own age but not my aspirations who was drinking herself to death. Â Â Â Â Â Â Â Â  To support myself while writing poems, I took the first job the Harvard personnel office suggestedâ€”as secretary to Dr. Frank Carpenter, a paleoentomologist and recent chairman of Harvardâ€™s Biology Department. The department was quartered in the Bio Labs on Divinity Avenue, an impressive pile whose front entrance was guarded by a pair of giant bronze rhinoceroses. Dr. Carpenter published a bug quarterly called Psyche. Now that he was through with his chairmanship, he wanted to turn more attention to it, and he needed someone who could spell and knew where the commas should go. Iâ€™d do fine. Â Â Â Â Â Â Â Â  One year of extremely introductory biology was the extent of my exposure to science at Wellesley. It was taught by Mrs. Houck, a sweet, hopeful woman who had us cut up frogs (I wouldnâ€™t) and one day took us on a field trip to Paramecium Pond, a reedy puddle in mid-campus next to a magnificent pine tree with come-hither branches. Up this I went, quickly and quietly, with a like-minded pal, and we hid there until Mrs. Houck and the crowd of giggling future biologists marched off. Then we climbed down and went back to the dorm for lunch. Â Â Â Â Â Â Â Â  C+ from Mrs. Houck. The ""plus"" was nice of her. ~~ So I typed and took dictation and proofread for Professor Carpenter, a formal, exacting, but kind boss, and poked around the Bio Labs, which I found exotic. Every Wednesday afternoon, Dr. Carpenter would host a tea in his ""lab,"" a large room off his office proper, dominated by a long table large enough for a dozen invitees to gather. (One Wednesday, on the way into town to pick up the cookies, I ran into Mrs. Houck on the Bio Labâ€™s front steps; her eyes widened in surpriseâ€”or perhaps shockâ€”when I told her I was working there.) Any member of the Biology faculty who was interested in something called ""the Modern Synthesis,"" or in fossil insects as they bore on evolution, was free to attend these weekly teas. The Modern Synthesis was essentially the marriage of Darwin and Mendel, goosed by new advances in molecular biology. I know that now, but I didnâ€™t then (and wouldnâ€™t have cared). Â Â Â Â Â Â Â Â  Because I made the coffee and got the cookies, I was allowed to sit at the tea table with the guys. They were mostly old-guard Harvard biologists, one exception being Ed Wilson, a young assistant professor and ant-man (short trousers, white socks) whose considerably more interesting lab was across the hall from Dr. Carpenterâ€™s. Ed had an ant colony in a large glass terrarium, and he told me I was free to visit whenever I wanted, to watch the ants crawling all over each other in their underground tunnels. Â Â Â Â Â Â Â Â  Others I remember from the tea were the evolutionary biologist Ernst Mayr, the director of the Museum of Comparative Zoology, which adjoined the Bio Labs; Bill Brown, the MCZâ€™s associate curator of entomology; and Herbert Levi, its associate curator of arachnology. Stephen Jay Gould was around at the time, but I donâ€™t recall him coming. Â Â Â Â Â Â Â Â  James D. Watson was around, too, recently recruited to bolster molecular biology at Harvardâ€”but he would not have been caught dead at that table. To Watson, Harvardâ€™s biologists were just morphologistsâ€”dinosaurs. What were bug fossils to the discoverer of the structure of DNA? He used to carry a water pistol in the halls and amuse himself by squirting at themâ€”or so I was told. The disdain was mutual. I encountered Watson myself one morning in the Bickâ€”Hayes-Bickford cafeteria, which was an intellectual hub on Mass Ave. People spent all day in there, over coffee and an occasional English muffin, in spite of the ""No Loitering"" sign posted by the desperate management. I was at the counter when I sensed an enormously tall person staring at me with intense protruding eyes. ""Would you like to have breakfast with me?"" he blurted out. By then I knew how non grata he was, so I said yes. He was probably lonely. Unfortunately I cannot now remember anything else he said. Â Â Â Â Â Â Â Â  Anyway, these Wednesday teas were lively affairs, with lots of camaraderie and animated cross-talk about such matters as changes in wing venation from the Lower to the Upper Carboniferous, or who planned to give what ""paper"" at the next meeting of ""the triple-A-S."" Sometimes, in an effort to get them to talk about something interesting, I would mention a book Iâ€™d just read, or a film festival at the Brattle, and they would smile politely at me and renew their discussion of Blattaria and its stunning illumination of modern evolutionary theory. Â Â Â Â Â Â Â Â  Iâ€™m twenty, mind you. I felt very sorry for them. I thought they were wasting their lives. ~~ That would change, but not quite yet. Â Â Â Â Â Â Â Â  One afternoon I went over to the MCZ to watch Dr. Levi feed the tarantula he kept in his fourth-floor digs. The tarantula was fed once a week on waterbugs (Blatta orientalis), which Dr. Levi collected from the halls of the Bio Labs, where they were abundant. These bugs were so big that they were reportedly able to climb the stairs between floors instead of riding on an elevator. The feeding was an unforgettable spectacle. Seizing the waterbug in a pair of tweezers, Dr. Levi dropped it into the terrarium housing his tarantula. After a few ominous seconds, there was a scuffling motion in a little cave in a mossy pile of rocks, from which the tarantula emerged and . . . swoosh!!. . . plunged its two glistening fangs into the flailing insect. Â Â Â Â Â Â Â Â  It would take a while, said Dr. Levi, for the venom to liquify all the nice parts of the waterbug, so I didnâ€™t stick around for that. Instead I started down the MCZâ€™s stairs on the way back to my own mossy cave in the Bio Labs. On a landing halfway down, I stopped and looked into the hall to my left. Why? To this day, I donâ€™t know. There I saw a whitewashed office door, and, very faintly, beneath the paint, I could read a name: ""V. Nabokov."" Â Â Â Â Â Â Â Â  This was electrifying. I knew that the author of the wondrous Lolita was a lepidopterist and had taught for a while (before my time) at Wellesley, only 15 minutesâ€™ drive from the MCZ. Could this have been . . . his office? Now I would have something to talk about at the next teaâ€”a link, at last, between my predilections and theirs! So next Wednesday, at the first lull in the conversation, I jumped in: Â Â Â Â Â Â Â Â  ""Guess what I saw in the MCZ the other day!"" Â Â Â Â Â Â Â Â  Polite, puzzled gazes. Â Â Â Â Â Â Â Â  ""I saw a door with â€˜V. Nabokovâ€™ on it, painted over. Could that have been Vladimir Nabokovâ€™s office?"" Â Â Â Â Â Â Â Â  Dead silence. They all seemed to be looking at their shoes. This went on for an ungodly length of time. Finally, Professor Carpenter, at the head of the table, turned to me and remarked gently, ""Sara, Iâ€™m afraid that some of us think he turned out rather badly."" Â Â Â Â Â Â Â Â  ""Iâ€™ve got to get out of here,"" I thought. And I did, some months later, when I left Cambridgeâ€”and the garret, where Iâ€™d written exactly one poemâ€”for New York and wound up at The New Yorker, where (I liked to think) I belonged. But it seems that I was not the same person. I hadnâ€™t managed to change any of the Harvard entomologists, but they had changed me. (This dawned on me, slowly, as I worked on a number of profilesâ€”I. I. Rabi, Hans Bethe, Marvin Minsky, Michele Bessoâ€”by the physicist Jeremy Bernstein, one of the magazineâ€™s few science journalists.) It was their zeal, their patient attention to detail, their utter, absolute faith in the fundamental importance of understanding Where We Are and Whatâ€™s Going On. Â Â Â Â Â Â Â Â  I did a one-eighty and ended up checking and eventually editing most of the science pieces in The New Yorker for the next thirty years. A kind of mid-career validation came when, invited to give a talk about science editing at the 1988 meeting of the American Association for the Advancement of Science (the tea-table ""triple-A-S"") in Boston, I ran into Ed (now ""E. O."" and famous) Wilson. I was sitting on a bench outside the auditorium, going over my notes, when he came striding down the hall swinging his briefcase. I jumped up and reintroduced myself. ""I was hoping to go to your talk,"" I said, ""but Iâ€™ve got to miss it, because Iâ€™m giving a talk at the same time."" Â Â Â Â Â Â Â Â  Baffled pause. Â Â Â Â Â Â Â Â  ""Youâ€™re . . . giving a talk??"" Â Â Â Â Â Â Â Â  ""Yes,"" I said, ignoring the bafflement. ""Iâ€™ll be talking about that tea table."" Â Â Â Â Â Â Â Â  ""Iâ€™m talking about that tea table, too!"" said Wilson. ""And Iâ€™ve got slides!"" ~~ Continue Reading â†’ Â  It seems like yesterday, butÂ EdgeÂ has been up and running for twenty-twoÂ years. Twenty-two years in which it has channeled a fast-flowing river of ideas from the academic world to the intellectually curious public. The range of topics runs from the cosmos to the mind and every piece allows the reader at least a glimpse and often a serious look at the intellectual world of a thought leader in a dynamic field of science. Presenting challenging thoughts and facts in jargon-free language has also globalized the trade of ideas across scientific disciplines.Â EdgeÂ is a site where anyone can learn, and no one can be bored. The statistics are awesome: TheÂ EdgeÂ conversation is a ""manuscript"" of close to 10 million words, with nearly 1,000 contributors whose work and ideas are presented in more than 350 hours of video, 750 transcribed conversations, and thousands of brief essays. And these activities have resulted in the publication of 19 printed volumes of short essays and lectures in English and in foreign language editions throughout the world. The public response has been equally impressive:Â Edge'sÂ influence is evident in its Google Page Rank of Â ""8"", the same asÂ The Atlantic, The Economist, The New Yorker,Â The Wall Street Journal,Â and theÂ Washington Post, in the enthusiastic reviews in major general-interest outlets, and in the more than 700,000 books sold.Â  Of course, none of this would have been possible without the increasingly eager participation of scientists in theÂ EdgeÂ enterprise. And a surprise: brilliant scientists can also write brilliantly! Answering theÂ EdgeÂ question evidently became part of the annual schedule of many major figures in diverse fields of research, and the steadily growing number of responses is another measure of the growing influence of theÂ EdgeÂ phenomenon. Is now the right time to stop? Many readers and writers will miss further installments of the annualÂ EdgeÂ questionâ€”they should be on the lookout for the next form in which theÂ EdgeÂ spirit will manifest itself. What is the secret ofÂ Edgeâ€™s success? To begin with, the charisma of John Brockman, its founder and leader. Add to that his eclectic but discerning taste in the choice of participants. The two major formats ofÂ EdgeÂ activities are no less important. The interviews are edited to make the interviewer invisible. Masking the questioner is not new, but remarkable skill is required to elicit both clarity and depth in seamless expositions of the participantsâ€™ ideas.Â EdgeÂ interviews read and sound like coherently constructed informal lecturesâ€”a surprising feat when the flow of the content is entirely driven by the interviewerâ€™s questions. The short-essay format of theÂ EdgeÂ Annual Question is a daring innovation and a striking success. Apparently, 600-1,000 words is the sweet spot for introducing one big idea. The brevity disciplines the author and allows the reader to grasp the essential pointâ€”and to remain hungry for more even as she moves to another essay. The unifying message in the story ofÂ EdgeÂ is that ideas matter, and they matter to many. They can be told with elegance, sometimes with wit, never with condescension. There is a large audience eager to learn what scientists in various disciplines are up to, and a large group of scientist-teachers eager to tell their stories. And certainly, there will be more stories.Â  [Originally published onÂ Edge, 5.22.19] Continue Reading â†’ John Brockman, Editor and Publisher"
Essays,https://paulgraham.com/articles.html,1705642963,,unread,
Kurzweil,https://www.kurzweilai.net/,1674981009,,unread,"Skip to content             More stories on progress Ray Kurzweil is a best-selling author, pioneering inventor, and futurist. novel by Ray Kurzweil an adventure for all ages click to learn about the book     More bulletin board    More resources Â©
				2025			"
Welcome to Linux From Scratch!,https://www.linuxfromscratch.org/,1709287709,,unread,"









 


Web

LFS
 Linux From Scratch (LFS) is a project that provides you with
        step-by-step instructions for building your own custom Linux system,
        entirely from source code.
      Currently, the Linux From Scratch organization consists of the following
        subprojects:
      Â© 1998-2025 Gerard Beekmans. Website design by Jeremy Huntwork &
                 Matthew Burgess."
CSS Layout - The position Property,http://www.w3schools.com/css/css_positioning.asp,1451253827,css,unread,"
                W3Schools offers a wide range of services and products for
                beginners and professionals,
                
                helping millions of people everyday to learn and master new
                skills.
               
                      Enjoy our free tutorials like millions of other internet
                      users since 1999
                     
                      Explore our selection of references covering all popular
                      coding languages
                     
                      Create your own website with
                      W3Schools Spaces
                      - no setup required
                     Test your skills with different exercises Test yourself with multiple choice questions Document your knowledge 
                      Create a
                      free
                      W3Schools Account to Improve Your Learning Experience
                     
                      Track your learning progress at W3Schools and collect
                      rewards
                     
                      Become a PLUS user and unlock powerful features (ad-free,
                      hosting, support,..)
                     
                      Not sure where you want to start? Follow our guided path
                     
                      With our online code editor, you can edit code and view
                      the result in your browser
                     
                      Learn the basics of HTML in a fun and engaging video
                      tutorial
                     
                      We have created a bunch of responsive website templates
                      you can use - for free!
                     
                      Host your own website, and share it to the world with
                      W3Schools Spaces
 
                      Create your own server using Python, PHP, React.js,
                      Node.js, Java, C#, etc.
                     
                      Large collection of code snippets for HTML, CSS and
                      JavaScript
                     
                      Build fast and responsive sites using our free
                      W3.CSS
                      framework
                     Read long term trends of browser usage Test your typing speed 
                      Use our color picker to find different RGB, HEX and HSL
                      colors.
                      
 
                      W3Schools Coding Game! Help the lynx collect pine cones
                      
 
                      Join our newsletter and get access to exclusive content
                      every month
                     
                      Contact us about W3Schools Academy for educational
                      institutions
                     
                      Contact us about W3Schools Academy for your organization
                     
                      About sales:
                      sales@w3schools.com

                      About errors:
                      help@w3schools.com
 Check out our refererence page with all the emojis supported in HTML
                      ðŸ˜Š
 Check out our full UTF-8 Character reference CSS positioning is about controlling the placement of elements within a web page. With CSS positioning, you can override the normal document flow. The position property specifies the positioning 
type for an element. This property can have one of the following values:  Elements are then positioned to their final location with the 
top, 
bottom, 
left, and 
right properties. All HTML elements are positioned static by default. Static positioned elements are not affected by the top, bottom, left, and right properties. An element with position: static; is always positioned according to the normal flow of the page: Here is the CSS that is used: An element with position: relative; is positioned relative to its normal position 
in the document flow. Setting the top, right, bottom, and left properties will cause
the element to be adjusted away from its normal position. Other content will not be adjusted to fit into any gap left by the 
element. Here is the CSS that is used: An element with position: fixed; is positioned relative to the viewport, which means it always 
stays in the same place even if the page is scrolled. The top, 
right, bottom, and left properties are used set the final location of the element. A fixed element does not leave a gap in the page where it would normally have been located. Notice the fixed element in the lower-right corner of the page. Here is the CSS that is used: An element with position: absolute; is positioned relative to the nearest positioned ancestor 
(with position other than static). However; if an absolute positioned element has no positioned ancestors, 
it uses the document body, and moves along with page scrolling. Note: Absolute positioned elements are removed from the normal 
document flow, and can overlap other elements. Here is a simple example: Here is the CSS that is used: An element with position: sticky; toggles between 
a relative and fixed 
position, depending on the scroll position. A sticky element is positioned relative until a certain scroll position is 
reached - then it ""sticks"" in that place (like position:fixed). Note: You must specify at least one of the top, right, bottom or left 
properties, for 
sticky positioning to work. In this example, when the sticky element reach the top of the page 
(top: 0), it sticks to this position: How to position text on an image: Try it Yourself: If you want to use W3Schools services as an educational institution, team or enterprise, send us an e-mail:sales@w3schools.com If you want to report an error, or if you want to make a suggestion, send us an e-mail:help@w3schools.com"
SQLCourse - Interactive Online SQL Training for Beginners,http://www.sqlcourse.com/,1498798676,,unread,"SQLCourse is a unique SQL tutorial website that not only provides easy-to-understand SQL instructions at your correct level, but it allows you to practice what you learn using the online SQL interpreter.  Our Beginner SQL Course is the perfect place to start if you are new to the world of database programming or database administration. In addition to learning basic SQL commands and syntax â€“ such as how to insert, update, and delete information from tables â€“ users will be able to practice those same commands through our free online SQL interpreter. Enter SQL commands to receive immediate results and experiment to better understand how database concepts such as table drops and table selects work. The SQL tutorial and online interpreter currently supports a subset of ANSI SQL. The basics of commands such as select, insert, update, delete, and drop will be covered in this gentle introduction to Structured Query Language (SQL). If you are already familiar with the basics of SQL, you can still use this database course as a refresher and practice common SQL commands and statements. This unique SQL database tutorial builds on the Beginner Course. It provides budding database programmers and db admins with more advanced, easy-to-follow SQL instructions and the ability to practice what you learn on-line with immediate feedback, thanks to our SQL interpreter! You will receive immediate results on a web page after submitting your SQL Commands. This continuation course will provide you with critical need-to-know advanced features and clauses of the select statement that were not supported in the previous SQLCourse.com site. Everything you learn here will be ANSI SQL compliant and should work with most SQL databases, including Oracle, SQL Server, MySQL, MS Access, Informix, Sybase, or any other ANSI SQL compliant database. If you are already familiar with advanced SQL commands and database administration concepts, you can still use this course as a refresher, and practice some SQL statements. SQL is simple to learn. SQL syntax is straightforward and is human readable, meaning even non-programmers can learn it. SQL is fast and lightweight. Large amounts of data can be easily processed in a matter of seconds, allowing for responses to complex queries in no time. SQL is an industry standard, approved by ISO and ANSI for use with relational databases and RDBMS. SQL is portable, meaning it can be used on PCs that run Windows, Linux, and Mac OS. It can also run on servers and embedded devices, meaning your databases can run in practically any environment or device. SQLCourse is a unique SQL tutorial website that not only provides easy-to-understand SQL instructions geared towards your level of knowledge, but it also allows developers and database administrators the ability to practice what you learn using a free online SQL interpreter. Advertiser Disclosure: Some of the products that appear on this site are from companies from which TechnologyAdvice receives compensation. This compensation may impact how and where products appear on this site including, for example, the order in which they appear. TechnologyAdvice does not include all companies or all types of products available in the marketplace."
Eloquent JavaScript,https://eloquentjavascript.net/,1709824372,javascript,unread,
HowTo/Sorting - Python Wiki,https://wiki.python.org/moin/HowTo/Sorting,1650256204,python,unread,"
Sorting Mini-HOW TO
Original version by Andrew Dalke with a major update by Raymond Hettinger Contents
Sorting Mini-HOW TO
Sorting Basics
Key Functions
Operator Module Functions
Ascending and Descending
Sort Stability and Complex Sorts
The Old Way Using Decorate-Sort-Undecorate
The Old Way Using the cmp Parameter
Maintaining Sort Order
Odd and Ends Python lists have a built-in sort() method that modifies the list in-place and a sorted() built-in function that builds a new sorted list from an iterable. There are many ways to use them to sort data and there doesn't appear to be a single, central place in the various manuals describing them, so I'll do so here. 
Sorting Basics
A simple ascending sort is very easy -- just call the sorted() function. It returns a new sorted list: >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Original version by Andrew Dalke with a major update by Raymond Hettinger Contents
Sorting Mini-HOW TO
Sorting Basics
Key Functions
Operator Module Functions
Ascending and Descending
Sort Stability and Complex Sorts
The Old Way Using Decorate-Sort-Undecorate
The Old Way Using the cmp Parameter
Maintaining Sort Order
Odd and Ends Python lists have a built-in sort() method that modifies the list in-place and a sorted() built-in function that builds a new sorted list from an iterable. There are many ways to use them to sort data and there doesn't appear to be a single, central place in the various manuals describing them, so I'll do so here. 
Sorting Basics
A simple ascending sort is very easy -- just call the sorted() function. It returns a new sorted list: >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Contents
Sorting Mini-HOW TO
Sorting Basics
Key Functions
Operator Module Functions
Ascending and Descending
Sort Stability and Complex Sorts
The Old Way Using Decorate-Sort-Undecorate
The Old Way Using the cmp Parameter
Maintaining Sort Order
Odd and Ends Python lists have a built-in sort() method that modifies the list in-place and a sorted() built-in function that builds a new sorted list from an iterable. There are many ways to use them to sort data and there doesn't appear to be a single, central place in the various manuals describing them, so I'll do so here. 
Sorting Basics
A simple ascending sort is very easy -- just call the sorted() function. It returns a new sorted list: >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Contents
Sorting Mini-HOW TO
Sorting Basics
Key Functions
Operator Module Functions
Ascending and Descending
Sort Stability and Complex Sorts
The Old Way Using Decorate-Sort-Undecorate
The Old Way Using the cmp Parameter
Maintaining Sort Order
Odd and Ends Python lists have a built-in sort() method that modifies the list in-place and a sorted() built-in function that builds a new sorted list from an iterable. There are many ways to use them to sort data and there doesn't appear to be a single, central place in the various manuals describing them, so I'll do so here. 
Sorting Basics
A simple ascending sort is very easy -- just call the sorted() function. It returns a new sorted list: >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] There are many ways to use them to sort data and there doesn't appear to be a single, central place in the various manuals describing them, so I'll do so here. 
Sorting Basics
A simple ascending sort is very easy -- just call the sorted() function. It returns a new sorted list: >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
Sorting Basics
A simple ascending sort is very easy -- just call the sorted() function. It returns a new sorted list: >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] A simple ascending sort is very easy -- just call the sorted() function. It returns a new sorted list: >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> sorted([5, 2, 3, 1, 4])
[1, 2, 3, 4, 5]You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient. >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Another difference is that the list.sort() method is only defined for lists.  In contrast, the sorted() function accepts any iterable. >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
Key Functions
Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons. For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] For example, here's a case-insensitive string comparison: >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> sorted(""This is a test string from Andrew"".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record. A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] A common pattern is to sort complex objects using some of the object's indices as a key.  For example: >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] The same technique works for objects with named attributes.  For example: >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> class Student:
        def __init__(self, name, grade, age):
                self.name = name
                self.grade = grade
                self.age = age
        def __repr__(self):
                return repr((self.name, self.grade, self.age))
        def weighted_grade(self):
                return 'CBA'.index(self.grade) / float(self.age)

>>> student_objects = [
        Student('john', 'A', 15),
        Student('jane', 'B', 12),
        Student('dave', 'B', 10),
]
>>> sorted(student_objects, key=lambda student: student.age)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
Operator Module Functions
The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] The key-function patterns shown above are very common, so Python provides convenience functions to make accessor functions easier and faster.  The operator module has itemgetter, attrgetter, and starting in Python 2.6 a methodcaller function. Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Using those functions, the above examples become simpler and faster. >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> from operator import itemgetter, attrgetter, methodcaller

>>> sorted(student_tuples, key=itemgetter(2))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(student_objects, key=attrgetter('age'))
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] The operator module functions allow multiple levels of sorting. For example, to sort by grade then by age: >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> sorted(student_tuples, key=itemgetter(1,2))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

>>> sorted(student_objects, key=attrgetter('grade', 'age'))
[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] The third function from the operator module, methodcaller is used in the following example in which the weighted grade of each student is shown before sorting on it: >>> [(student.name, student.weighted_grade()) for student in student_objects]
[('john', 0.13333333333333333), ('jane', 0.08333333333333333), ('dave', 0.1)]
>>> sorted(student_objects, key=methodcaller('weighted_grade'))
[('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)]
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
Ascending and Descending
Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Both list.sort() and sorted() accept a reverse parameter with a boolean value.  This is using to flag descending sorts. For example, to get the student data in reverse age order: >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

>>> sorted(student_objects, key=attrgetter('age'), reverse=True)
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
Sort Stability and Complex Sorts
Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Starting with Python 2.2, sorts are guaranteed to be stable. That means that when multiple records have the same key, their original order is preserved. >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> sorted(data, key=itemgetter(0))
[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Notice how the two records for 'blue' retain their original order so that ('blue',Â 1) is guaranteed to precede ('blue',Â 2). This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] This wonderful property lets you build complex sorts in a series of sorting steps.  For example, to sort the student data by descending grade and then ascending age, do the age sort first and then sort again using grade: >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
>>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] The Timsort algorithm used in Python does multiple sorts efficiently because it can take advantage of any ordering already present in a dataset. 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
The Old Way Using Decorate-Sort-Undecorate
This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] This idiom is called Decorate-Sort-Undecorate after its three steps: First, the initial list is decorated with new values that control the sort order. Second, the decorated list is sorted. Finally, the decorations are removed, creating a list that contains only the initial values in the new order. For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] For example, to sort the student data by grade using the DSU approach: >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
>>> decorated.sort()
>>> [student for grade, i, student in decorated]               # undecorate
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] This idiom works because tuples are compared lexicographically; the first items are compared; if they are the same then the second items are compared, and so on. It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] It is not strictly necessary in all cases to include the index i in the decorated list. Including it gives two benefits: The sort is stable - if two items have the same key, their order will be preserved in the sorted list. The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly. Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] The original items do not have to be comparable because the ordering of the decorated tuples will be determined by at most the first two items. So for example the original list could contain complex numbers which cannot be sorted directly.  Another name for this idiom is Schwartzian transform, after Randal L. Schwartz, who popularized it among Perl programmers. For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] For large lists and lists where the comparison information is expensive to calculate, and Python versions before 2.4, DSU is likely to be the fastest way to sort the list.  For 2.4 and later, key functions provide the same functionality. 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
The Old Way Using the cmp Parameter
Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Many constructs given in this HOWTO assume Python 2.4 or later. Before that, there was no sorted() builtin and list.sort() took no keyword arguments. Instead, all of the Py2.x versions supported a cmp parameter to handle user specified comparison functions. In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] In Py3.0, the cmp parameter was removed entirely (as part of a larger effort to simplify and unify the language, eliminating the conflict between rich comparisons and the __cmp__ methods). In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] In Py2.x, sort allowed an optional function which can be called for doing the comparisons.  That function should take two arguments to be compared and then return a negative value for less-than, return zero if they are equal, or return a positive value for greater-than.  For example, we can do: >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> def numeric_compare(x, y):
        return x - y
>>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
[1, 2, 3, 4, 5]Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Or you can reverse the order of comparison with: >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> def reverse_numeric(x, y):
        return y - x
>>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
[5, 4, 3, 2, 1]When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] When porting code from Python 2.x to 3.x, the situation can arise when you have the user supplying a comparison function and you need to convert that to a key function.  The following wrapper makes that easy to do: def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return KTo convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] To convert to a key function, just wrap the old comparison function: >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
[5, 4, 3, 2, 1]In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] In Python 2.7, the cmp_to_key() tool was added to the functools module. 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] 
Maintaining Sort Order
Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Python does not provide modules like C++'s set and map data types as part of its standard library. This is a concious decision on the part of Guido, et al to preserve ""one obvious way to do it."" Instead Python delegates this task to third-party libraries that are available on the Python Package Index. These libraries use various techniques to maintain list, dict, and set types in sorted order. Maintaining order using a specialized data structure can avoid very slow behavior (quadratic run-time) in the naive approach of editing and constantly re-sorting. Several implementations are described here. Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines. Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation. Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython. Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types. Python banyan Module - Provides a fast, C-implementation for dict and set data types. Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types. Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C. 
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] Python SortedContainers Module - Pure-Python implementation that is fast-as-C implementations. Implements sorted list, dict, and set data types. Testing includes 100% code coverage and hours of stress. Documentation includes full API reference, performance comparison, and contributing/development guidelines.  Python rbtree Module - Provides a fast, C-implementation for dict and set data types. Based on a red-black tree implementation.  Python treap Module - Provides a sorted dict data type. Uses a treap for implementation and improves performance using Cython.  Python bintrees Module - Provides several tree-based implementations for dict and set data types. Fastest implementations are based on AVL and Red-Black trees. Implemented in C. Extends the conventional API to provide set operations for dict data types.  Python banyan Module - Provides a fast, C-implementation for dict and set data types.  Python skiplistcollections Module - Pure-Python implementation based on skip-lists providing a limited API for dict and set data types.  Python blist Module - Provides sorted list, dict and set data types based on the ""blist"" data type, a B-tree implementation. Implemented in Python and C.  
Odd and Ends
For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function. The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))To create a standard sort order for a class, just add the appropriate rich comparison methods: >>> Student.__eq__ = lambda self, other: self.age == other.age
>>> Student.__ne__ = lambda self, other: self.age != other.age
>>> Student.__lt__ = lambda self, other: self.age < other.age
>>> Student.__le__ = lambda self, other: self.age <= other.age
>>> Student.__gt__ = lambda self, other: self.age > other.age
>>> Student.__ge__ = lambda self, other: self.age >= other.age
>>> sorted(student_objects)
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement. Key functions need not access data internal to objects being sorted.  A key function can also access external resources.  For instance, if the student grades are stored in a dictionary, they can be used to sort a separate list of student names: >>> students = ['dave', 'john', 'jane']
>>> newgrades = {'john': 'F', 'jane':'A', 'dave': 'C'}
>>> sorted(students, key=newgrades.__getitem__)
['jane', 'dave', 'john'] For locale aware sorting, use locale.strxfrm() for a key function or locale.strcoll() for a comparison function.  The reverse parameter still maintains sort stability (i.e. records with equal keys retain the original order).  Interestingly, that effect can be simulated without the parameter by using the builtin reversed function twice: >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
>>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data)))) For general purpose comparisons, the recommended approach is to define all six rich comparison operators.  The functools.total_ordering class decorator makes this easy to implement.  HowTo/Sorting  (last edited 2014-10-12 06:26:39 by Paddy3118) Unable to edit the page? See the FrontPage for instructions."
Relational Databases and the Semantic Web (in Design Issues),https://www.w3.org/DesignIssues/RDB-RDF.html,1509639072,web semantico,unread,"
Date: September 1998.
 
      $Id: RDB-RDF.html,v 1.25 2009/08/27 21:38:09 timbl Exp $
     
        Status: . Editing status: Comments please. An parenthetical
        discussion to the Web
        Architecture at 50,000 feet. and the Semantic Web roadmap.
       
Up to Design Issues
 
      There are many other data models which RDF's Directed
      Labelled Graph (DLG) model compares closely with, and maps
      onto. See a summary in
     
      One is the Relational Database (RDB) model.
     
      Is the RDF model an entity-relationship mode? Yes and no. It
      is great as a basis for ER-modelling, but because RDF is used
      for other things as well, RDF is more general. RDF is a model
      of entities (nodes) and relationships. If you are used to the
      ""ER"" modelling system for data, then the RDF model is
      basically an openning of the ER model to work on the Web. In
      typical ER model involved entity types, and for each entity
      type there are a set of relationships (slots in the typical
      ER diagram). The RDF model is the same, except that
      relationships are first class objects: they are identified by
      a URI, and so anyone can make one. Furthurmore, the set of
      slots of an object is not defined when the class of an object
      is defined. The Web works though anyone being (technically)
      allowed to say anything about anything. This means that a
      relationship between two objects may be stored apart from any
      other information about the two objects. This is different
      from object-oriented systems often used to implement ER
      models, which generally assume that information about an
      object is stored in an object: the definition of the class of
      an object defines the storage implied for its properties.
     
      For example, one person may define a vehicle as having a
      number of wheels and a weight and a length, but not foresee a
      color. This will not stop another person making the assertion
      that a given car is red, using the color vocabular from
      elsewhere.
     
      Apart from this simple but significant change, many concepts
      involved in the ER modelling take across directly onto the
      Semantic Web model.
     
      The semantic web data model is very directly connected with
      the model of relational databases. A relational database
      consists of tables, which consists of rows, or records. Each
      record consists of a set of fields. The record is nothing but
      the content of its fields, just as an RDF node is nothing but
      the connections: the property values. The mapping is very
      direct
     
      Indeed, one of the main driving forces for the Semantic web,
      has always been the expression, on the Web, of the vast
      amount of relational database information in a way that can
      be processsed by machines.
     
      RDF's serialization format -- its syntax in XML -- is a very
      suitable format for expressing relational database
      information.
     
      Relational database systems manage RDF data, but in a
      specialized way. In a table, there are many records with the
      same set of properties. An individual cell (which corresponds
      to an RDF property) is not often thought of on its own. SQL
      queries can join tables and extract data from tables, and the
      result is generally a table. So, the practical use for which
      RDB software is used typically optimized for doing operations
      with a small number of tables some of which may have a large
      number of elements.
     
      A fundamental aspect of a database table is that often the
      data in a table can be definitive. Neither RDF nor RDB models
      have simple ways of expressing this. For example, not only
      does a row in a table indicate that there is a red car whose
      Massachusetts plate is ""123XYZ"", but the table may also carry
      the unwritten semantics that if any car has a Massachusetts
      plate then it must be in the table. (If any RDF node has
      ""Massachusetts plate number"" property then than node is a
      member of the table) The scope of the uniquenes of a value is
      in fact a very interest property.
     
      The original RDB model defined by E.F. Codd included
      datatyping with inheritance, which he had intended would be
      implememnted in the RDB products to a greater extent that it
      has. For example, typically a person's home address house
      number may be typed as an an integer, and their shoe size may
      also be also be typed as an integer. One can as a result join
      to tables through those fields, or list people whose shoe
      size equals their house number. Practical RDB systems leave
      it to the application builder to only make operations which
      make sense. Once a database is expreted onto the Web, it
      becomes possible to do all kinds of strange combinations, so
      a stronger typing becomes very useful: it becomes a set of
      inference rules.
     
      In a pure RDB model, every table has a primary key: a column
      whose value can be used to uniquely identify every row. Some
      products do not enforce this, leading to an ambiguity in the
      significance of duplicate rows. A curious feature is that the
      primary key can be changed without changing the identity of a
      row. (A person can change their name for example). SQL allows
      tables to be set up so that such changes can cascade through
      the local system to preseve referential integrity. This
      clearly won't work on the Web. One solution is to use a row
      ID -- which many systems do in fact use although SQL doesn't
      expose it in a standard way. Another is for the application
      to coinstrain the primary key not to change. Another is to
      put up with links breaking.
     
      RDB systems have datatypes at the atomic (unstructured)
      level, as RDF and XML will/do. Combination rules tend in RDBs
      to be loosely enforced, in that a query can join tables by
      any columns which match by datatype -- without any check on
      the semantics. You could for example create a list of houses
      that have the same number as rooms as an employee's shoe
      size, for every employee, even though the sense of that would
      be questionable.
     
      The new SQL99 standard is going to include new
      object-oriented features, such as inherited typing and
      structured contents of cells - arrays and structs. This RDB
      model with things from the OO world. I don't deal with that
      here in that the RDF model works as a lowest commoin
      denominator being able to express either and both.
     
      A difference between XML/RDF schemas (and SGML) on the one
      hand and database schemas on the other is the expectation
      that there will be a relatively small number of XML/RDF
      schemas. Many web sites will export documents whose structure
      is defined by the same schema, and this is in fact what
      provides the interoperability.
     
      A database schema is, as fasr as I know, created
      independently for each database. Even if a million companies
      clone the same form of employee database, there will be a
      million schemas, one for each database.
     
      It may be that RDF will fill a simple role in simply
      expressing the equivalence of the terms in each database
      schema.
     
      In order to be able to access a table, and make extra
      statements about it which will enable its use in more and
      more ways, the essential objects of the table must be
      exported as first class objects on the Web.
     
      When mapping any system onto the Web, the mapping into URI
      space is critical. Here we are doing this common operation
      generically for all relational databases. It is obviously
      usefuil for this to be done in a consistent ways between
      multiple vendors would be useful - an area for possible
      standardization.
     
      Here is a random example I may have gotten wrong, basd on
      whatI understand of the naming within databases. The database
      itself is defined within a schema which is listed in a
      catalog.
     
      2002 version, see real
      code implemented by Dan Connolly:
     
              Database description of database ""personnel""
             
              (say - whatever)
             
              (Arbitrary, must not clash, linked by
              db:describes from
              personnel)
             
              (Arbitrary, must not clash with table names, linked
              by db:allData from
              personnel)
             
              personnel/employees#.table
             
              (was: personnel#employees, but changed to allow it to
              be deref'd to giev useful data)
             
              (defined in personnel)
             
              (Convention. The bit of the
              classname before the #)
             
              (Arbitrary, must not clash, linked by
              db:tableSchemas from
              personnel/employees)
             
              (Defined in personnel/employees)
             
              (Arbitrary, must not clash, linked by
              db:tableData from
              personnel/employees)
             
              (Convention. Note the primary key
              value must be encoded suitably!)
             
              personnel/employees/1234#item
             
              (Convention)
             
              (when primary key exists, then employees#_data etc
              use this URIref for the item 1234 intead of making
              anonymous nodes)
             
              (employees/_data#1234?@@)
             
              (Convention)
             
              (arbitrary, linked by
              db:sqlService from
              personnel if supported.)
             
              (arbitrary, linked by
              db:formService from
              personnel if supported)
             
              personnel/_postme
             
              (arbitrary, linked by
              db:deltaService from
              personnel if supported. Could be same URI
              personnel in fact, as we are dealing
              iwth a different method)
             
      @@@ How to use typing to indicate that the URI in the table
      is a (relative?) URI to another object, not a string?
     
      @@@ This works fine when implemented live on a database.
      However, it is a little tricky to emulate in a typical
      file-based web server because of the use of ""personnel"" in
      this case both as directory and as
     
      One of the things which makes life easier is to make the
      mapping so that the relative URI syntax can be used to
      advantage. For example, here, everything within the database
      (the scope of an SQL statement) can be writted as a short
      URI.
     
      There is a question as to how much of the SQL query syntax
      should be turned into identifier. For example, is a query on
      a primary key really an identifier? Is the extraction of a
      single cell really an identifier? It would be useful to be
      able to treat them as such. However, it would be wiser to use
      the ""?"" convention to indicate a generalized SQL idempotent
      query. (A URL should of course
never be used to refer to the results of a
      table-changing operation such as UPDATE or DELETE. In this
      case, if HTTP were used, an SQL query should IMHO be POST ed
      to the database URI. Of course, you can use your favorite
      networked database access protocol)
     
      In the above the column name of the table could be refered to
      using the table as a namespace, a row for example being
     
      and one row of the the result of joining this table (of
      people) and another table (about people) by their primary
      keys would use namespaces from both tables:
     
This has been elaborated with help of an RDB tutorial and
      discussion from Andrew Eisenberg/Sybase.
     
      See also: Why RDF is more than XML
 
Up to Design Issues; back to
      Architecture from 50,000ft
 
      timbl
    "
"NPR Music: Tiny Desk, New Music and Music News : NPR",https://www.npr.org/music/,1674664828,,unread,"
                So much more than a singer and songwriter, Connie Lim is a talented storyteller and activist who uses her music to inspire advocacy.
                
                    
                    NPR
                    
                
hide caption
 So much more than a singer and songwriter, Connie Lim is a talented storyteller and activist who uses her music to inspire advocacy. 
                So much more than a singer and songwriter, Connie Lim is a talented storyteller and activist who uses her music to inspire advocacy.
                
                    
                    NPR
                    
                
hide caption
 what to read, watch and listen to now 
                Conan Gray's, who's worked his way up from the YouTube content mines to become a pop star in his own right. enters this week's chart at No. 3 with his album Wishbone.
                
                    
                    Katja Ogrin/Redferns/Redferns
                    
                
hide caption
 KPop Demon Hunters pulls off something no soundtrack has ever accomplished. 
                Donna Kelce stands with her son Kansas City Chiefs tight end Travis Kelce and Taylor Swift after the AFC Championship NFL football game against the Buffalo Bills on Jan. 26 in Kansas City, Mo.
                
                    
                    Ashley Landis/AP
                    
                
hide caption
 Swift announced the engagement Tuesday: ""Your English teacher and your gym teacher are getting married."" 
STAR LINE comes six years after Chance The Rapper's studio debut The Big Day, which ended the hot streak he'd enjoyed on his 2010s mixtape run, but may have set him on a radical new path.
                
                    
                    Keeley Parenteau
                    
                
hide caption
 STAR LINE recasts the affable indie rapper as something sharper-eged. the latest from npr music from npr music and the npr network 
Alt.Latino

                    
                    NPR
                    
                
hide caption
 Ecuadorian-American indie pop, 2010s Tumblr-core and bedroom pop cumbia feature on this episode.  
                Disiniblud's ""Give-upping"" is one of the songs we can't stop playing this week.
                
                    
                    Allegra Messina
                    
                
hide caption
 We update our running list of the year's best songs with glitched-out ear candy and raging rock. 
                World Cafe Tile
                
                    
                    NPR
                    
                
hide caption
 Natalie Bergman discusses how My Home is Not in This World was sparked by new beginnings. 
                Greg Freeman
                
                    
                    Justin Gordon
                    
                
hide caption
 Greg Freeman. Mac Demarco. Earl Sweatshirt. Stephen Thompson and  Tad Cautious discuss the best new albums out now. 
                The Late Set
                hide caption
 ""Live at the Village Vanguard"" is one of the most familiar phrases in the jazz discography. But why? Al Jardine talks about Brian Wilson's recent passing and growing up making music with the Beach Boys. Watch live concerts, studio sessions and music documentaries Ty Segall: Tiny Desk Concert Guster: Tiny Desk Concert Nduduzo Makhathini: Tiny Desk Concert Omar: Tiny Desk Concert Mekons: Tiny Desk Concert MIKE: Tiny Desk Concert River Tiber: Tiny Desk Concert Sierra Hull: Tiny Desk Concert Sasha Keable: Tiny Desk Concert PUP: Tiny Desk Concert Rusowsky: Tiny Desk Concert ANOHNI and the Johnsons: Tiny Desk Concert Bloc Party: Tiny Desk Concert Clipse: Tiny Desk Concert Wet Leg: Tiny Desk Concert TakÃ¡cs Quartet: Tiny Desk Concert Gillian Welch & David Rawlings: Tiny Desk Concert Rico Nasty: Tiny Desk Concert Living Colour: Tiny Desk Concert Alex Isley: Tiny Desk Concert Beenie Man: Tiny Desk Concert Stanley Clarke: Tiny Desk Concert CeCe Winans: Tiny Desk Concert Wiz Khalifa: Tiny Desk Concert Amerie: Tiny Desk Concert E-40: Tiny Desk Concert Ruby Ibarra: Tiny Desk Concert The Cast of Buena Vista Social Club: Tiny Desk Concert ARTEMIS: Tiny Desk Concert Death Becomes Her: Tiny Desk Concert CarÃ­n LeÃ³n: Tiny Desk Concert Beth Gibbons: Tiny Desk Concert Katie Gavin: Tiny Desk Concert Jeff Parker ETA IVtet: Tiny Desk Concert SUNSET BLVD.: Tiny Desk Concert PJ Sin Suela: Tiny Desk Concert Madison McFerrin: Tiny Desk Concert Grupo Frontera: Tiny Desk Concert Gypsy: Tiny Desk Concert Sharon Isbin & Amjad Ali Khan's Strings for Peace: Tiny Desk Concert Panda Bear: Tiny Desk Concert Illuminati Hotties: Tiny Desk Concert Yu Sakai feat. TBN Trio: Tiny Desk Concert Nubya Garcia: Tiny Desk Concert Bad Bunny: Tiny Desk Concert REBOLU: Tiny Desk Concert Zar Electrik: Tiny Desk x globalFEST Chocolate Droppa: Tiny Desk Concert public radio music streams hand-picked songs curated by the NPR Music staff 
                A sparkly sweet treat for a sparkly sweet mix.
                
                    
                    Lars Gotrich/NPR
                    
                
hide caption
 You asked, we listened: RosÃ©wave is back! Our summer playlist series returns with syrupy sweet songs from the likes of Amerie, Wednesday, Addison Rae, Marvin Gaye. 
                Disco Beethoven
                
                    
                    Chris Sharon
                    
                
hide caption
 Roll down the car windows and crank up the jams. Our annual summer bangers playlist is here, fueled by a wide array of high-octane favorites from Beethoven, Mahler, Bruckner and BartÃ³k to Glass, Reich, Adams and Julia Wolfe. 
                Comic book artist Daniel Warren Johnson (Murder Falcon, Extremity) illustrates the music of Viking's Choice. Horns up!
                
                    
                    Daniel Warren Johnson
                    
                
hide caption
 Comic book artist Daniel Warren Johnson (Murder Falcon, Extremity) illustrates the music of Viking's Choice. Horns up! A mixtape featuring Josie's lilting twee, ente's urgent rock and roll, Ellen Aarkbro's pipe organ drone, nuvolascara's chaotic screamo, Stereolab's return.  public radio music shows 
                All Songs Considered
                
                    
                    Frank Chimero/NPR
                    
                
hide caption
 Robin Hilton spins new music from emerging bands and musical icons. What Latinidad sounds like, presented by Felix Contreras and Anamaria Sayre. 
                Fresh Air Interviews
                
                    
                    Frank Chimero/NPR
                    
                
hide caption
 Terry Gross interviews luminary artists about their lives and musical work 
                From the Top
                
                    
                    Frank Chimero/NPR
                    
                
hide caption
 NPR Music presents From The Top program highlights. For the complete From The Top program website, visit www.fromthetop.org. 
                Jazz Night In America
                
                    
                    NPR
                    
                
hide caption
 Jazz Night In America is a public radio program, a video concert documentary series, and an online home for the music, from NPR Music, WBGO and Jazz at Lincoln Center. KCRW's Jason Bentley hosts a weekly spin of the best electronic, dance and beyond. Live recordings from the award-winning public radio program, hosted by Kathy Mattea. 
                Piano Jazz
                
                    
                    Frank Chimero/NPR
                    
                
hide caption
 Each week, NPR's award-winning program showcases both acclaimed artists and up-and-coming performers as they share music and memories. 
                The Thistle & Shamrock
                
                    
                    Frank Chimero/NPR
                    
                
hide caption
 Award-winning radio host Fiona Ritchie explores evolving music from Celtic roots in Europe and North America. 
                World Cafe
                
                    
                    Frank Chimero/NPR
                    
                
hide caption
 WXPN in Philadelphia and host Raina Douris present interviews and performances with today's essential and emerging artists. Sponsor Message Become an NPR sponsor"
